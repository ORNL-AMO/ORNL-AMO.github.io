<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AMO-Tools-Suite: include/fast-cpp-csv-parser/README.md Source File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../smicon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AMO-Tools-Suite
   &#160;<span id="projectnumber">v.0.9.0</span>
   </div>
   <div id="projectbrief">Set of tools for calculating energy efficiency in industrial equipment</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">include/fast-cpp-csv-parser/README.md</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# Fast C++ CSV Parser</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;This is a small, easy-to-use and fast header-only library for reading comma separated value (CSV) files. </div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;## Features</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  * Automatically rearranges columns by parsing the header line.</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  * Disk I/O and CSV-parsing are overlapped using threads for efficiency.</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  * Parsing features such as escaped strings can be enabled and disabled at compile time using templates. You only pay in speed for the features you actually use.</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;  * Can read multiple GB files in reasonable time.</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  * Support for custom columns separators (i.e. Tab separated value files are supported), quote escaped strings, automatic space trimming. </div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  * Works with `*`nix and Windows newlines and automatically ignores UTF-8 BOMs.</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  * Exception classes with enough context to format useful error messages. what() returns error messages ready to be shown to a user. </div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;## Getting Started</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;The following small example should contain most of the syntax you need to use the library.</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;```cpp</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;# include &quot;csv.h&quot;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;int main(){</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;  io::CSVReader&lt;3&gt; in(&quot;ram.csv&quot;);</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;  in.read_header(io::ignore_extra_column, &quot;vendor&quot;, &quot;size&quot;, &quot;speed&quot;);</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;  std::string vendor; int size; double speed;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;  while(in.read_row(vendor, size, speed)){</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    // do stuff with the data</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;  }</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;}</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;```</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;## Installation</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;The library only needs a standard conformant C++11 compiler. It has no further dependencies. The library is completely contained inside a single header file and therefore it is sufficient to copy this file to some place on your include path. The library does not have to be explicitly build. </div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;Note however, that threads are used and some compiler (for example GCC) require you to link against additional librarie to make it work. With GCC it is important to add -lpthread as the last item when linking, i.e. the order in </div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;```</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;g++ -std=c++0x a.o b.o -o prog -lpthread</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;```</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;is important. If you for some reason do not want to use threads you can define CSV_IO_NO_THREAD before including the header.</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;Remember that the library makes use of C++11 features and therefore you have to enable support for it (f.e. add -std=c++0x or -std=gnu++0x). </div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;The library was developed and tested with GCC 4.6.1</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;Note that VS2013 is not C++11 compilant and will therefore not work out of the box. See [here](https://code.google.com/p/fast-cpp-csv-parser/issues/detail?id=6) for what needs to be adjusted to make the code work.</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;## Documentation</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;The libary provides two classes: </div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;  * `LineReader`: A class to efficiently read large files line by line.</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;  * `CSVReader`: A class that efficiently reads large CSV files.</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;Note that everything is contained in the `io` namespace.</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;### `LineReader`</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;```cpp</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;class LineReader{</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;public:</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;  // Constructors</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;  LineReader(some_string_type file_name);</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  LineReader(some_string_type file_name, std::FILE*source);</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;  LineReader(some_string_type file_name, std::istream&amp;source);</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;  LineReader(some_string_type file_name, std::unique_ptr&lt;ByteSourceBase&gt;source);</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;  // Reading</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;  char*next_line();</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;  // File Location</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  void set_file_line(unsigned);</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  unsigned get_file_line()const;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  void set_file_name(some_string_type file_name);</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;  const char*get_truncated_file_name()const;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;};</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;```</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;The constructor takes a file name and optionally a data source. If no data source is provided the function tries to open the file with the given name and throws an `error::can_not_open_file exception` on failure. If a data source is provided then the file name is only used to format error messages. In that case you can essentially put any string there. Using a string that describes the data source results in more informative error messages.</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;`some_string_type` can be a `std::string` or a `char*`. If the data source is a `std::FILE*` then the library will take care of calling `std::fclose`. If it is a `std::istream` then the stream is not closed by the library. For best performance open the streams in binary mode. However using text mode also works. `ByteSourceBase` provides an interface that you can use to implement further data sources. </div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;```cpp</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;class ByteSourceBase{</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;public:</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  virtual int read(char*buffer, int size)=0;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;  virtual ~ByteSourceBase(){}</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;};</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;```</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;The read function should fill the provided buffer with at most `size` bytes from the data source. It should return the number of bytes actually written to the buffer. If data source has run out of bytes (because for example an end of file was reached) then the function should return 0. If a fatal error occures then you can throw an exception. Note that the function can be called both from the main and the worker thread. However, it is guarenteed that they do not call the function at the same time. </div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;Lines are read by calling the `next_line` function. It returns a pointer to a null terminated C-string that contains the line. If the end of file is reached a null pointer is returned. The newline character is not included in the string. You may modify the string as long as you do not write past the null terminator. The string stays valid until the destructor is called or until next_line is called again. Windows and `*`nix newlines are handled transparently. UTF-8 BOMs are automatically ignored and missing newlines at the end of the file are no problem.</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;**Important:** There is a limit of 2^24-1 characters per line. If this limit is exceeded a `error::line_length_limit_exceeded` exception is thrown.</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;Looping over all the lines in a file can be done in the following way.</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;```cpp</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;LineReader in(...);</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;while(char*line = in.next_line()){</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;  ...</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;}</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;```</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;The remaining functions are mainly used used to format error messages. The file line indicates the current position in the file, i.e., after the first `next_line` call it is 1 and after the second 2. Before the first call it is 0. The file name is truncated as internally C-strings are used to avoid `std::bad_alloc` exceptions during error reporting.</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;**Note:** It is not possible to exchange the line termination character.</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;### `CSVReader`</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;`CSVReader` uses policies. These are classes with only static members to allow core functionality to be exchanged in an efficient way.</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;```cpp</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;template&lt;</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  unsigned column_count,</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;  class trim_policy = trim_chars&lt;&#39; &#39;, &#39;\t&#39;&gt;, </div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  class quote_policy = no_quote_escape&lt;&#39;,&#39;&gt;,</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  class overflow_policy = throw_on_overflow,</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;  class comment_policy = no_comment</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;&gt;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;class CSVReader{</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;public:</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;  // Constructors</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;  // same as for LineReader</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;  // Parsing Header</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;  void read_header(ignore_column ignore_policy, some_string_type col_name1, some_string_type col_name2, ...);</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;  void set_header(some_string_type col_name1, some_string_type col_name2, ...);</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  bool has_column(some_string_type col_name)const;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;  // Read</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;  char*next_line();</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;  bool read_row(ColType1&amp;col1, ColType2&amp;col2, ...);</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;  // File Location </div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;  void set_file_line(unsigned);</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;  unsigned get_file_line()const;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;  void set_file_name(some_string_type file_name);</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  const char*get_truncated_file_name()const;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;};</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;```</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;The `column_count` template parameter indicates how many columns you want to read from the CSV file. This must not necessarily coincide with the actual number of columns in the file. The three policies govern various aspects of the parsing.</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;The trim policy indicates what characters should be ignored at the begin and the end of every column. The default ignores spaces and tabs. This makes sure that</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;```</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;a,b,c</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;1,2,3</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;```</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;is interpreted in the same way as</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;```</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;  a, b,   c</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;1  , 2,   3</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;```</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;The trim_chars can take any number of template parameters. For example `trim_chars&lt;&#39; &#39;, &#39;\t&#39;, &#39;_&#39;&gt; `is also valid. If no character should be trimmed use `trim_chars&lt;&gt;`.</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;The quote policy indicates how string should be escaped. It also specifies the column separator. The predefined policies are:</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;  * `no_quote_escape&lt;sep&gt;` : Strings are not escaped. &quot;`sep`&quot; is used as column separator.</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;  * `double_quote_escape&lt;sep, quote&gt;` : Strings are escaped using quotes. Quotes are escaped using two consecutive quotes. &quot;`sep`&quot; is used as column separator and &quot;`quote`&quot; as quoting character.</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;**Important**: When combining trimming and quoting the rows are first trimmed and then unquoted. A consequence is that spaces inside the quotes will be conserved. If you want to get rid of spaces inside the quotes, you need to remove them yourself.</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;**Important**: Quoting can be quite expensive. Disable it if you do not need it.</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;The overflow policy indicates what should be done if the integers in the input are too large to fit into the variables. There following policies are predefined:</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;  * `throw_on_overflow` : Throw an `error::integer_overflow` or `error::integer_underflow` exception.</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;  * `ignore_overflow` : Do nothing and let the overflow happen.</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;  * `set_to_max_on_overflow` : Set the value to `numeric_limits&lt;...&gt;::max()` (or to the min-pendant).</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;The comment policy allows to skip lines based on some criteria. Valid predefined policies are:</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;  * `no_comment` : Do not ignore any line.</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;  * `empty_line_comment` : Ignore all lines that are empty or only contains spaces and tabs. </div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;  * `single_line_comment&lt;com1, com2, ...&gt;` : Ignore all lines that start with com1 or com2 or ... as the first character. There may not be any space between the beginning of the line and the comment character. </div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;  * `single_and_empty_line_comment&lt;com1, com2, ...&gt;` : Ignore all empty lines and single line comments.</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;Examples:</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;  * `CSVReader&lt;4, trim_chars&lt;&#39; &#39;&gt;, double_quote_escape&lt;&#39;,&#39;,&#39;\&quot;&#39;&gt; &gt;` reads 4 columns from a normal CSV file with string escaping enabled.</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;  * `CSVReader&lt;3, trim_chars&lt;&#39; &#39;&gt;, no_quote_escape&lt;&#39;\t&#39;&gt;, single_line_comment&lt;&#39;#&#39;&gt; &gt;` reads 3 columns from a tab separated file with string escaping disabled. Lines starting with a # are ignored.</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;The constructors and the file location functions are exactly the same as for `LineReader`. See its documentation for details.</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;There are three methods that deal with headers. The `read_header` methods reads a line from the file and rearranges the columns to match that order. It also checks whether all necessary columns are present. The `set_header` method does *not* read any input. Use it if the file does not have any header. Obviously it is impossible to rearrange columns or check for their availability when using it. The order in the file and in the program must match when using `set_header`. The `has_column` method checks whether a column is present in the file. The first argument of `read_header` is a bitfield that determines how the function should react to column mismatches. The default behavior is to throw an `error::extra_column_in_header` exception if the file contains more columns than expected and an `error::missing_column_in_header` when there are not enough. This behavior can be altered using the following flags.</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;  * `ignore_no_column`: The default behavior, no flags are set</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;  * `ignore_extra_column`: If a column with a name is in the file but not in the argument list, then it is silently ignored.</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;  * `ignore_missing_column`: If a column with a name is not in the file but is in the argument list, then `read_row` will not modify the corresponding variable. </div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;When using `ignore_column_missing` it is a good idea to initialize the variables passed to `read_row` with a default value, for example:</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;```cpp</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;// The file only contains column &quot;a&quot;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;CSVReader&lt;2&gt;in(...);</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;in.read_header(ignore_missing_column, &quot;a&quot;, &quot;b&quot;);</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;int a,b = 42;</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;while(in.read_row(a,b)){</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;  // a contains the value from the file</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;  // b is left unchanged by read_row, i.e., it is 42</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;}</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;```</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;If only some columns are optional or their default value depends on other columns you have to use `has_column`, for example:</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;```cpp</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;// The file only contains the columns &quot;a&quot; and &quot;b&quot;</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;CSVReader&lt;2&gt;in(...);</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;in.read_header(ignore_missing_column, &quot;a&quot;, &quot;b&quot;, &quot;sum&quot;);</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;if(!in.has_column(&quot;a&quot;) || !in.has_column(&quot;b&quot;))</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;  throw my_neat_error_class();</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;bool has_sum = in.has_column(&quot;sum&quot;);</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;int a,b,sum;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;while(in.read_row(a,b,sum)){</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;  if(!has_sum)</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    sum = a+b;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;}</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;```</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;**Important**: Do not call `has_column` from within the read-loop. It would work correctly but significantly slowdown processing.</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;If two columns have the same name an error::duplicated_column_in_header exception is thrown. If `read_header` is called but the file is empty a `error::header_missing` exception is thrown.</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;The `next_line` functions reads a line without parsing it. It works analogous to `LineReader::next_line`. This can be used to skip broken lines in a CSV file. However, in nearly all applications you will want to use the `read_row` function.</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;The `read_row` function reads a line, splits it into the columns and arranges them correctly. It trims the entries and unescapes them. If requested the content is interpreted as integer or as floating point. The variables passed to read_row may be of the following types.</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;  * builtin signed integer: These are `signed char`, `short`, `int`, `long` and `long long`. The input must be encoded as a base 10 ASCII number optionally preceded by a + or -. The function detects whether the integer is too large would overflow (or underflow) and behaves as indicated by overflow_policy.</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;  * builtin unsigned integer: Just as the signed counterparts except that a leading + or - is not allowed.</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;  * builtin floating point: These are `float`, `double` and `long double`. The input may have a leading + or -. The number must be base 10 encoded. The decimal point may either be a dot or a comma. (Note that a comma will only work if it is not also used as column separator or the number is escaped.) A base 10 exponent may be specified using the &quot;1e10&quot; syntax. The &quot;e&quot; may be lower- or uppercase. Examples for valid floating points are &quot;1&quot;, &quot;-42.42&quot; and &quot;+123.456E789&quot;. The input is rounded to the next floating point or infinity if it is too large or small.</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;  * `char`: The column content must be a single character.</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;  * `std::string`: The column content is assigned to the string. The std::string is filled with the trimmed and unescaped version.</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;  * `char*`: A pointer directly into the buffer. The string is trimmed and unescaped and null terminated. This pointer stays valid until read_row is called again or the CSVReader is destroyed. Use this for user defined types. </div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;Note that there is no inherent overhead to using `char*` and then interpreting it compared to using one of the parsers directly build into `CSVReader`. The builtin number parsers are pure convenience. If you need a slightly different syntax then use `char*` and do the parsing yourself.</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;## FAQ</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;Q: The library is throwing a std::system_error with code -1. How to get it to work?</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;A: Your compiler&#39;s std::thread implementation is broken. Define CSV\_IO\_NO\_THREAD to disable threading support.</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;Q: My values are not just ints or strings. I want to parse my customized type. Is this possible?</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;A: Read a `char*` and parse the string. At first this seems expensive but it is not as the pointer you get points directly into the memory buffer. In fact there is no inherent reason why a custom int-parser realized this way must be any slower than the int-parser build into the library. By reading a `char*` the library takes care of column reordering and quote escaping and leaves the actual parsing to you. Note that using a std::string is slower as it involves a memory copy.</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;Q: I get lots of compiler errors when compiling the header! Please fix it. :(</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;A: Have you enabled the C++11 mode of your compiler? If you use GCC you have to add -std=c++0x to the commandline. If this does not resolve the problem, then please open a ticket.</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;Q: The library crashes when parsing large files! Please fix it. :(</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;A: When using GCC have you linked against -lpthread? Read the installation section for details on how to do this. If this does not resolve the issue then please open a ticket. (The reason why it only crashes only on large files is that the first chuck is read synchronous and if the whole file fits into this chuck then no asynchronous call is performed.) Alternatively you can define CSV\_IO\_NO\_THREAD.</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;Q: Does the library support UTF?</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;A: The library has basic UTF-8 support, or to be more precise it does not break when passing UTF-8 strings through it. If you read a `char*` then you get a pointer to the UTF-8 string. You will have to decode the string on your own. The separator, quoting, and commenting characters used by the library can only be ASCII characters.</div></div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
